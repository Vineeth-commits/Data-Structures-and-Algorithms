Chapter 1

    1.1 Identifiers and keywords
        > Identifiers are basically names given to program elements such as variables, arrays, and functions.
        > Keywords are reserved words which have a special meaning and shouldnt be used as an identifier.
        > By convention, keywords must be written in lower-case.
    1.2 Data types
        > In the memory characters are stored in their ASCII code (Binary form).
        > C supports 4 modifiers - signed, unsigned, short and long.
    1.3 Variables and constants
        > A variable is defined as a meaningful name given to a data storage location in the computer memory. 
        > Declaring an constant -
            const float pi = 3.14;
    1.4 Header files
        string.h : for string handling functions
        stdlib.h : for some miscellaneous functions
        stdio.h : for standardized input and output functions
        math.h : for mathematical functions
        alloc.h : for dynamic memory allocation
        conio.h : for clearing the screen
    1.5 Unary operators
        > ++x is equivalent to x = x +1;
        > y = x++ is equivalent to y = x;x = x + 1;
    1.6 Break and continue statements
        > The break statement is used to terminate the execution of the nearest enclosing loop in which it appears.
        > The continue statement skips the code following it and jumps to the next iteration of the nearest loop.
        > To use both (or one of them) the jump statements, a loop is required which has to be enclosed.
    1.7 Passing parameters to functions
        > call by value: The values of the variables are passed by the calling function to the called function.Values of the variables in the calling functions remain unaffected when the arguments are passed using the call-by-value technique.
        > call by reference: The addresses of the variables are passed by the calling function to the called function. The function can change the value of the argument and the change is reflected in the calling function.
    1.8 Pointers
        > Every variable has a value and its address to its memory location.
        > A pointer is a variable which contains the memory location of another variable.
        > Pointer can be used for dynamic memory allocation of a variable. Ex:
            int *ptr;int n=1;
            ptr = &n;
        > *(&n) is equivalent to n;
        > Postfix unary increment (++) and decrement (––) operators have greater precedence than the dereference operator (*).  Therefore, the expression *ptr++ is equivalent to *(ptr++).
        > Null pointer is a pointer variable that doesnt point to any memory location.
            int *p = NULL;
        > A null pointer can also be declared by equating to 0. To make it clear, use 'NULL'.
        > Generic pointers or void pointers is a special pointer that can point to variables of any data type. Use it unless it is necassary.
        > In C, since you cannot have a variable of type void, the void pointer will therefore not point to any data and, thus, cannot be dereferenced. You need to cast a void pointer to another kind of pointer before using it.
        > To point to another pointer, use * for each level of reference. Ex:
            int x = 1;
            int *p, **p2;
            p = &x;
            p2 = &p;
            //printing **p2 will result to 1

    1.9 miscellaneous
        > The address of the variable is denoted by an & sign followed by the name of the variable in scanf().
        > In case of reading strings, we do not use the & sign in the scanf function.
        > The expression x << y is equivalent to multiplication of x by 2y. And the expression x >> y is equivalent to division of x by 2y if x is unsigned or has a non-negative value.
        > Switch executes faster than if-else statements.
        > Do-while is the only iterative loop which checks condition after running the loop body.
        > On 32 bit systems, integer variable is allocated 4 bytes while on 16 bit systems it is allocated 2 bytes.
        > Modulus operator (%) can only be applied on integer operands, and not on float or double operands.
        > Equality operators have lower precedence than relational operators.
        > Among all the operators, comma operator has the lowest precedence.
 
Chapter 2

    > An array is a collection of similar data elements. These data elements have the same data type. The elements of the array are stored in consecutive memory locations and are referenced by an index (also known as the subscript).
    > A linked list is a very flexible, dynamic data structure in which elements (called nodes) form a sequential list. 
    > A stack is a linear data structure in which insertion and deletion of elements are done at only one end, which is known as the top of the stack. Stack is called a last-in, first-out (LIFO) structure because the last element which is added to the stack is the first element which is deleted from the stack.
    > A queue is a first-in, first-out (FIFO) data structure in which the element that is inserted first is the first one to be taken out. The elements in a queue are added at one end called the rear and removed from the other end called the front.
    > A tree is a non-linear data structure which consists of a collection of nodes arranged in a hierarchical order. One of the nodes is designated as the root node, and the remaining nodes can be partitioned into disjoint sets such that each set is a sub-tree of the root.
    > A graph is a non-linear data structure which is a collection of vertices (also called nodes) and edges that connect these vertices. A graph is often viewed as a generalization of the tree structure, where instead of a purely parent-to-child relationship between tree nodes, any kind of complex relationships between the nodes can exist.
    > The time complexity of an algorithm is basically the running time of the program as a function of the input size.
    > The space complexity of an algorithm is the amount of computer memory required during the program execution as a function of the input size.

Chapter 3

    > Calculating the address of the array
        Address of data element, A[k] = BA(A) + w(k – lower_bound)
        A is the array, k is the index of the element of which we have to calculate the address, BA is the base address of the array A, and w is the size of one element in memory, for example, size of int is 2.
    > Calculating the length of the array
        Length = upper_bound – lower_bound + 1
    > Algorithm for traversing
        Step 1: [INITIALIZATION] SET I = lower_bound
        Step 2: Repeat Steps 3 to 4 while I <= upper_bound
        Step 3: Apply Process to A[I]
        Step 4: SET I = I + 1
            [END OF LOOP]
        Step 5: EXIT
    > Algorithm for insertion
        Step 1: [INITIALIZATION] SET I = N
        Step 2: Repeat Steps 3 and 4 while I >= POS
        Step 3: SET A[I + 1] = A[I]
        Step 4: SET I = I – 1
            [END OF LOOP]
        Step 5: SET N = N + 1
        Step 6: SET A[POS] = VAL
        Step 7: EXIT
    > Algorithm for deletion
        Step 1: [INITIALIZATION] SET I = POS
        Step 2: Repeat Steps 3 and 4 while I <= N – 1
        Step 3: SET A[I] = A[I + 1]
        Step 4: SET I = I + 1
            [END OF LOOP]
        Step 5: SET N = N – 1
        Step 6: EXIT
    > Row major and column major
        If the array elements are stored in column major order,
            Address(A[I][J]) = Base_Address + w{M ( J – 1) + (I – 1)}
        if the array elements are stored in row major order,
            Address(A[I][J]) = Base_Address + w{N ( I – 1) + (J – 1)}
        where w is the number of bytes required to store one element, N is the number of columns, M is the number of rows, and I and J are the subscripts of the array element.

Chapter 4
